#!/usr/bin/env python3
"""
Merit Badge Manager - Streamlit Web UI

A basic web interface for:
- Managing .env configuration settings
- Triggering CSV import and validation
- Displaying database views

Author: GitHub Copilot
Issue: #16
"""

import streamlit as st
import os
import sys
import sqlite3
import pandas as pd
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import logging
import shutil
from datetime import datetime

# Add the new layer directories to the Python path
sys.path.insert(0, str(Path(__file__).parent.parent / "database-access"))
sys.path.insert(0, str(Path(__file__).parent.parent / "database"))
sys.path.insert(0, str(Path(__file__).parent.parent / "scripts"))

from csv_validator import CSVValidator, ValidationResult, print_validation_summary
from roster_parser import RosterParser
from setup_database import create_database_schema

# Configure page
st.set_page_config(
    page_title="Merit Badge Manager",
    page_icon="üèïÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Application title
st.title("üèïÔ∏è Merit Badge Manager")
st.markdown("---")

def load_env_template() -> Dict[str, str]:
    """Load the .env.template file to get default values and structure."""
    env_template = {}
    template_path = Path(".env.template")
    
    if template_path.exists():
        with open(template_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_template[key] = value
    
    return env_template

def load_env_file() -> Dict[str, str]:
    """Load existing .env file if it exists."""
    env_vars = {}
    env_path = Path(".env")
    
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key] = value
    
    return env_vars

def save_env_file(env_vars: Dict[str, str]) -> bool:
    """Save environment variables to .env file."""
    try:
        with open(".env", 'w') as f:
            f.write("# Environment variables for Merit Badge Manager\n")
            f.write("# Generated by Streamlit UI\n\n")
            
            for key, value in env_vars.items():
                f.write(f"{key}={value}\n")
        
        return True
    except Exception as e:
        st.error(f"Error saving .env file: {e}")
        return False

def get_environment() -> str:
    """Get the current environment setting (development/production)."""
    try:
        env_vars = load_env_file()
        return env_vars.get('ENVIRONMENT', 'production').lower()
    except:
        return 'production'

def display_error_with_details(message: str, exception: Exception = None):
    """Display error message with optional detailed information in development mode."""
    st.error(message)
    
    # Show detailed error information in development mode
    if get_environment() == 'development' and exception:
        with st.expander("üîç Detailed Error Information (Development Mode)", expanded=False):
            st.code(f"Exception Type: {type(exception).__name__}")
            st.code(f"Exception Message: {str(exception)}")
            
            # Show traceback if available
            import traceback
            tb = traceback.format_exc()
            if tb != "NoneType: None\n":
                st.code(f"Traceback:\n{tb}")

def backup_database(db_path: str = "merit_badge_manager.db") -> Optional[str]:
    """
    Create a backup of the current database.
    
    Returns:
        Path to backup file if successful, None otherwise
    """
    if not Path(db_path).exists():
        return None
    
    try:
        # Ensure backups directory exists
        backups_dir = Path("backups")
        backups_dir.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"{Path(db_path).name}.backup_{timestamp}"
        backup_path = backups_dir / backup_filename
        shutil.copy2(db_path, backup_path)
        return str(backup_path)
    except Exception as e:
        st.error(f"Error creating database backup: {e}")
        return None

def restore_database(backup_path: str, db_path: str = "merit_badge_manager.db") -> bool:
    """
    Restore database from backup.
    
    Returns:
        True if successful, False otherwise
    """
    try:
        if Path(backup_path).exists():
            shutil.copy2(backup_path, db_path)
            return True
        return False
    except Exception as e:
        st.error(f"Error restoring database: {e}")
        return False

def recreate_database_safely(db_path: str = "merit_badge_manager.db") -> bool:
    """
    Safely recreate the database by handling file locks and ensuring clean deletion.
    
    Returns:
        True if successful, False otherwise
    """
    try:
        import time
        import sqlite3
        
        # First, try to close any existing connections by attempting a dummy connection
        # This helps ensure no lingering connections are holding locks
        if Path(db_path).exists():
            try:
                # Try to connect and immediately close to flush any pending operations
                conn = sqlite3.connect(db_path, timeout=1.0)
                conn.close()
                time.sleep(0.1)  # Brief pause to allow cleanup
            except:
                pass  # Ignore connection errors, we're just trying to clean up
            
            # Remove the existing database file
            try:
                Path(db_path).unlink()
                time.sleep(0.1)  # Brief pause after deletion
            except FileNotFoundError:
                pass  # File already gone, that's fine
            except PermissionError as e:
                st.error(f"‚ùå Cannot delete database file (file may be in use): {e}")
                return False
            except Exception as e:
                st.error(f"‚ùå Error deleting database file: {e}")
                return False
        
        # Create the new database schema
        success = create_database_schema(db_path, include_youth=True)
        if not success:
            st.error("‚ùå Database schema creation failed")
            return False
        
        return True
        
    except Exception as e:
        st.error(f"‚ùå Unexpected error during database recreation: {e}")
        return False

def display_validation_results(results: Dict[str, ValidationResult]) -> bool:
    """
    Display validation results in Streamlit format.
    
    Returns:
        True if all validations passed, False otherwise
    """
    overall_valid = True
    total_errors = 0
    total_warnings = 0
    
    st.subheader("üìã Validation Results")
    
    for file_type, result in results.items():
        # Create expandable section for each file type
        with st.expander(f"{'‚úÖ' if result.is_valid else '‚ùå'} {file_type} - {'PASS' if result.is_valid else 'FAIL'}", expanded=not result.is_valid):
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.metric("Rows Processed", result.row_count)
            with col2:
                st.metric("Valid Rows", result.valid_rows)
            with col3:
                st.metric("Skipped Rows", len(result.skipped_records), delta=None if len(result.skipped_records) == 0 else f"-{len(result.skipped_records)}")
            with col4:
                st.metric("Errors", len(result.errors), delta=None if len(result.errors) == 0 else f"-{len(result.errors)}")
            with col5:
                st.metric("Warnings", len(result.warnings), delta=None if len(result.warnings) == 0 else f"-{len(result.warnings)}")
            
            # Show skipped records
            if result.skipped_records:
                st.info("**Records skipped (duplicates):**")
                for skipped in result.skipped_records:
                    st.info(f"‚Ä¢ {skipped}")
            
            # Show errors
            if result.errors:
                st.error("**Errors found:**")
                for error in result.errors:
                    st.error(f"‚Ä¢ {error}")
            
            # Show warnings
            if result.warnings:
                st.warning("**Warnings found:**")
                for warning in result.warnings:
                    st.warning(f"‚Ä¢ {warning}")
        
        if not result.is_valid:
            overall_valid = False
        
        total_errors += len(result.errors)
        total_warnings += len(result.warnings)
    
    # Overall summary
    if overall_valid:
        st.success(f"üéâ **All validations passed!** Total warnings: {total_warnings}")
    else:
        st.error(f"‚ùå **Validation failed!** Total errors: {total_errors}, Total warnings: {total_warnings}")
        st.error("üö® Cannot proceed with import - Please fix validation errors first!")
    
    return overall_valid

def run_validation_only(roster_file_path: Path) -> Tuple[bool, Dict[str, ValidationResult]]:
    """
    Run validation on roster files and merit badge progress file and return results.
    
    Returns:
        Tuple of (overall_valid, results_dict)
    """
    try:
        # Parse the roster file to get adult and youth sections
        parser = RosterParser(str(roster_file_path), "output")
        adult_file, youth_file = parser.parse_roster()
        
        # Validate the parsed output files
        validator = CSVValidator()
        results = {}
        
        if os.path.exists(adult_file):
            results["Adult Roster"] = validator.validate_adult_roster(adult_file)
        
        if os.path.exists(youth_file):
            results["Youth Roster"] = validator.validate_youth_roster(youth_file)
        
        # Also validate Merit Badge Progress file if it exists
        current_env = load_env_file()
        mb_progress_file = current_env.get('MB_PROGRESS_CSV_FILE', 'merit_badge_progress.csv')
        data_dir = Path("data")
        mb_progress_path = data_dir / mb_progress_file
        
        if mb_progress_path.exists():
            results["Merit Badge Progress"] = validator.validate_mb_progress(str(mb_progress_path))
        
        # Calculate overall validity
        overall_valid = all(result.is_valid for result in results.values())
        
        return overall_valid, results
        
    except Exception as e:
        st.error(f"Validation error: {e}")
        return False, {}

def get_database_connection():
    """Get SQLite database connection."""
    db_path = "merit_badge_manager.db"
    if not Path(db_path).exists():
        return None
    
    try:
        conn = sqlite3.connect(db_path)
        return conn
    except Exception as e:
        st.error(f"Database connection error: {e}")
        return None

def get_available_views() -> List[str]:
    """Get list of available database views."""
    conn = get_database_connection()
    if not conn:
        return []
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='view' ORDER BY name;")
        views = [row[0] for row in cursor.fetchall()]
        conn.close()
        return views
    except Exception as e:
        st.error(f"Error fetching views: {e}")
        if conn:
            conn.close()
        return []

def get_scout_assignments_for_mbc(mbc_adult_id: int) -> List[Dict]:
    """Get all scout assignments for a specific MBC."""
    conn = get_database_connection()
    if not conn:
        return []
    
    try:
        query = """
        SELECT 
            scout_first_name,
            scout_last_name,
            scout_bsa_number,
            scout_rank,
            merit_badge_name,
            merit_badge_year,
            date_completed,
            requirements_raw,
            CASE 
                WHEN date_completed IS NOT NULL AND date_completed != '' THEN 'Completed'
                ELSE 'In Progress'
            END as status
        FROM merit_badge_progress 
        WHERE mbc_adult_id = ?
        ORDER BY scout_last_name, scout_first_name, merit_badge_name
        """
        
        cursor = conn.cursor()
        cursor.execute(query, (mbc_adult_id,))
        rows = cursor.fetchall()
        
        # Convert to list of dictionaries
        columns = [desc[0] for desc in cursor.description]
        assignments = []
        for row in rows:
            assignments.append(dict(zip(columns, row)))
        
        return assignments
        
    except Exception as e:
        st.error(f"Error fetching scout assignments: {e}")
        return []
    finally:
        conn.close()

def get_scout_mbcs_with_workload(scout_id: int) -> List[Dict]:
    """Get all MBCs for a specific Scout along with their workload data."""
    conn = get_database_connection()
    if not conn:
        return []
    
    try:
        query = """
        SELECT DISTINCT
            -- MBC Information
            a.id as mbc_adult_id,
            a.first_name || ' ' || a.last_name as mbc_name,
            a.email as mbc_email,
            a.bsa_number as mbc_bsa_number,
            
            -- Merit Badge Information for this Scout
            mbp.merit_badge_name,
            mbp.merit_badge_year,
            mbp.date_completed,
            CASE 
                WHEN mbp.date_completed IS NOT NULL AND mbp.date_completed != '' THEN 'Completed'
                ELSE 'In Progress'
            END as status,
            mbp.requirements_raw,
            
            -- MBC Workload Data (from mbc_workload_summary view)
            mws.total_assignments,
            mws.active_assignments,
            mws.completed_assignments,
            mws.unique_scouts_assigned,
            mws.unique_merit_badges,
            mws.merit_badges_counseling
            
        FROM merit_badge_progress mbp
        INNER JOIN adults a ON mbp.mbc_adult_id = a.id
        INNER JOIN mbc_workload_summary mws ON a.id = mws.mbc_adult_id
        WHERE mbp.scout_id = ?
        ORDER BY mbc_name, mbp.merit_badge_name
        """
        
        cursor = conn.cursor()
        cursor.execute(query, (scout_id,))
        rows = cursor.fetchall()
        
        # Convert to list of dictionaries
        columns = [desc[0] for desc in cursor.description]
        mbcs = []
        for row in rows:
            mbcs.append(dict(zip(columns, row)))
        
        return mbcs
        
    except Exception as e:
        st.error(f"Error fetching scout MBC assignments: {e}")
        return []
    finally:
        conn.close()

def display_mbc_modal(mbc_name: str, mbc_adult_id: int):
    """Display modal dialog with scout assignments for selected MBC."""
    st.markdown("---")
    st.subheader(f"üéØ Scout Assignments for {mbc_name}")
    
    # Get scout assignments
    assignments = get_scout_assignments_for_mbc(mbc_adult_id)
    
    if not assignments:
        st.info(f"No scout assignments found for {mbc_name}.")
        if st.button("Close", key="close_modal_empty"):
            st.session_state.selected_mbc = None
            st.rerun()
        return
    
    # Group assignments by scout
    scouts_dict = {}
    for assignment in assignments:
        scout_key = f"{assignment['scout_first_name']} {assignment['scout_last_name']}"
        if scout_key not in scouts_dict:
            scouts_dict[scout_key] = {
                'scout_info': {
                    'name': scout_key,
                    'bsa_number': assignment['scout_bsa_number'],
                    'rank': assignment['scout_rank']
                },
                'merit_badges': []
            }
        
        scouts_dict[scout_key]['merit_badges'].append({
            'name': assignment['merit_badge_name'],
            'year': assignment['merit_badge_year'],
            'status': assignment['status'],
            'requirements': assignment['requirements_raw'] or 'No requirements recorded'
        })
    
    # Display scout assignments
    st.write(f"**Total Scouts:** {len(scouts_dict)}")
    st.write(f"**Total Merit Badge Assignments:** {len(assignments)}")
    
    # Create responsive layout
    for scout_name, scout_data in scouts_dict.items():
        with st.expander(f"üìç {scout_name} - {scout_data['scout_info']['rank']} (BSA #{scout_data['scout_info']['bsa_number']})", expanded=True):
            
            # Merit badges for this scout
            st.write("**Merit Badges:**")
            
            for mb in scout_data['merit_badges']:
                col1, col2, col3 = st.columns([3, 1, 1])
                
                with col1:
                    status_emoji = "‚úÖ" if mb['status'] == 'Completed' else "üîÑ"
                    st.write(f"{status_emoji} **{mb['name']}** ({mb['year']})")
                    
                with col2:
                    if mb['status'] == 'Completed':
                        st.success("Completed")
                    else:
                        st.info("In Progress")
                
                with col3:
                    st.caption(f"Requirements: {mb['requirements'][:30]}{'...' if len(mb['requirements']) > 30 else ''}")
    
    # Close button
    st.markdown("---")
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚úñÔ∏è Close", key="close_modal", use_container_width=True):
            st.session_state.selected_mbc = None
            st.rerun()

def display_scout_mbc_modal(scout_name: str, scout_id: int, scout_bsa_number: int):
    """Display modal dialog with MBC assignments for selected Scout."""
    st.markdown("---")
    st.subheader(f"üéØ MBC Assignments for {scout_name}")
    
    # Get Scout's MBC assignments with workload data
    mbcs = get_scout_mbcs_with_workload(scout_id)
    
    if not mbcs:
        st.info(f"No MBC assignments found for {scout_name} (BSA #{scout_bsa_number}).")
        if st.button("Close", key="close_scout_modal_empty"):
            st.session_state.selected_scout = None
            st.rerun()
        return
    
    # Group MBCs by MBC name to show all merit badges they're working on with this Scout
    mbcs_dict = {}
    for mbc_assignment in mbcs:
        mbc_key = mbc_assignment['mbc_name']
        if mbc_key not in mbcs_dict:
            mbcs_dict[mbc_key] = {
                'mbc_info': {
                    'name': mbc_assignment['mbc_name'],
                    'email': mbc_assignment['mbc_email'],
                    'bsa_number': mbc_assignment['mbc_bsa_number'],
                    'adult_id': mbc_assignment['mbc_adult_id']
                },
                'workload': {
                    'total_assignments': mbc_assignment['total_assignments'],
                    'active_assignments': mbc_assignment['active_assignments'],
                    'completed_assignments': mbc_assignment['completed_assignments'],
                    'unique_scouts_assigned': mbc_assignment['unique_scouts_assigned'],
                    'unique_merit_badges': mbc_assignment['unique_merit_badges'],
                    'merit_badges_counseling': mbc_assignment['merit_badges_counseling']
                },
                'merit_badges': []
            }
        
        mbcs_dict[mbc_key]['merit_badges'].append({
            'name': mbc_assignment['merit_badge_name'],
            'year': mbc_assignment['merit_badge_year'],
            'status': mbc_assignment['status'],
            'requirements': mbc_assignment['requirements_raw'] or 'No requirements recorded'
        })
    
    # Display Scout and MBC assignments summary
    st.write(f"**Scout:** {scout_name} (BSA #{scout_bsa_number})")
    st.write(f"**Total MBCs:** {len(mbcs_dict)}")
    st.write(f"**Total Merit Badge Assignments:** {len(mbcs)}")
    
    st.markdown("---")
    
    # Display each MBC and their assignments
    for mbc_name, mbc_data in mbcs_dict.items():
        with st.expander(f"üë§ {mbc_name} - {mbc_data['mbc_info']['email']}", expanded=True):
            
            # MBC Workload Information
            st.subheader("üìä MBC Current Workload")
            col1, col2, col3, col4 = st.columns(4)
            
            with col1:
                st.metric("Total Scouts", mbc_data['workload']['unique_scouts_assigned'])
            with col2:
                st.metric("Active Assignments", mbc_data['workload']['active_assignments'])
            with col3:
                st.metric("Completed Assignments", mbc_data['workload']['completed_assignments'])
            with col4:
                st.metric("Merit Badges", mbc_data['workload']['unique_merit_badges'])
            
            # All Merit Badges this MBC counsels
            st.write("**All Merit Badges Counseled:**")
            mb_badges = mbc_data['workload']['merit_badges_counseling']
            if len(mb_badges) > 100:
                mb_badges = mb_badges[:100] + "..."
            st.caption(mb_badges)
            
            st.markdown("---")
            
            # Merit badges for this Scout with this MBC
            st.subheader(f"üèÖ Merit Badges with {scout_name}")
            
            for mb in mbc_data['merit_badges']:
                mb_col1, mb_col2, mb_col3 = st.columns([3, 1, 2])
                
                with mb_col1:
                    status_emoji = "‚úÖ" if mb['status'] == 'Completed' else "üîÑ"
                    st.write(f"{status_emoji} **{mb['name']}** ({mb['year']})")
                    
                with mb_col2:
                    if mb['status'] == 'Completed':
                        st.success("Completed")
                    else:
                        st.info("In Progress")
                
                with mb_col3:
                    requirements_text = mb['requirements'][:50] if mb['requirements'] else 'No requirements recorded'
                    if len(mb['requirements']) > 50:
                        requirements_text += "..."
                    st.caption(f"Requirements: {requirements_text}")
    
    # Close button
    st.markdown("---")
    col1, col2, col3 = st.columns([1, 1, 1])
    with col2:
        if st.button("‚úñÔ∏è Close", key="close_scout_modal", use_container_width=True):
            st.session_state.selected_scout = None
            st.rerun()

def refresh_mbc_workload_view():
    """Refresh the mbc_workload_summary view to ensure it has the latest structure."""
    conn = get_database_connection()
    if not conn:
        return False
    
    try:
        cursor = conn.cursor()
        
        # Drop the existing view
        cursor.execute("DROP VIEW IF EXISTS mbc_workload_summary")
        
        # Read the updated view definition from the SQL file
        view_sql_path = Path(__file__).parent.parent / "database" / "mbc_workload_summary_view.sql"
        if view_sql_path.exists():
            with open(view_sql_path, 'r') as f:
                view_sql = f.read()
            
            # Execute the new view creation
            cursor.execute(view_sql)
            conn.commit()
            return True
        else:
            st.error("View SQL file not found")
            return False
            
    except Exception as e:
        st.error(f"Error refreshing view: {e}")
        return False
    finally:
        conn.close()

def display_view_data(view_name: str):
    """Display data from a database view."""
    conn = get_database_connection()
    if not conn:
        st.warning("Database not found. Please import data first.")
        return
    
    try:
        # Special handling for MBC Workload Summary - refresh view if needed
        if view_name == 'mbc_workload_summary':
            # Try to query for mbc_adult_id column to see if view is updated
            try:
                pd.read_sql_query("SELECT mbc_adult_id FROM mbc_workload_summary LIMIT 1", conn)
            except Exception:
                # Column doesn't exist, refresh the view
                conn.close()
                if refresh_mbc_workload_view():
                    st.success("Updated MBC Workload Summary view structure")
                    conn = get_database_connection()
                else:
                    st.error("Failed to update view structure")
                    return
        
        df = pd.read_sql_query(f"SELECT * FROM {view_name}", conn)
        
        # Special handling for MBC Workload Summary
        if view_name == 'mbc_workload_summary':
            display_mbc_workload_with_modal(df)
        # Special handling for Scout views with clickable names
        elif view_name == 'active_scouts_with_positions':
            display_scouts_roster_with_modal(df)
        else:
            st.dataframe(df, use_container_width=True)
        
        # Display record count
        st.info(f"Total records: {len(df)}")
        
    except Exception as e:
        st.error(f"Error loading view {view_name}: {e}")
    finally:
        conn.close()

def display_mbc_workload_with_modal(df: pd.DataFrame):
    """Display MBC workload summary with clickable MBC names that open modal dialogs."""
    
    # Initialize session state for selected MBC
    if 'selected_mbc' not in st.session_state:
        st.session_state.selected_mbc = None
    
    # Check if modal should be displayed
    if st.session_state.selected_mbc:
        mbc_info = st.session_state.selected_mbc
        display_mbc_modal(mbc_info['name'], mbc_info['adult_id'])
        return
    
    # Display MBC workload summary table with clickable names
    st.write("**Click on an MBC name to view their scout assignments**")
    
    # Create a custom display of the dataframe with clickable MBC names
    for index, row in df.iterrows():
        with st.container():
            col1, col2, col3, col4, col5, col6 = st.columns([3, 1, 1, 1, 1, 2])
            
            with col1:
                # Make MBC name clickable
                if st.button(
                    f"üë§ {row['mbc_name']}", 
                    key=f"mbc_{row['mbc_adult_id']}",
                    help=f"Click to view scout assignments for {row['mbc_name']}"
                ):
                    st.session_state.selected_mbc = {
                        'name': row['mbc_name'],
                        'adult_id': row['mbc_adult_id'],
                        'email': row['email']
                    }
                    st.rerun()
                
                st.caption(f"‚úâÔ∏è {row['email']}")
            
            with col2:
                st.metric("Total", row['total_assignments'])
            
            with col3:
                st.metric("Active", row['active_assignments'])
            
            with col4:
                st.metric("Completed", row['completed_assignments'])
            
            with col5:
                st.metric("Scouts", row['unique_scouts_assigned'])
            
            with col6:
                merit_badges = str(row['merit_badges_counseling'])
                if len(merit_badges) > 40:
                    merit_badges = merit_badges[:40] + "..."
                st.caption(f"Merit Badges: {merit_badges}")
        
        st.markdown("---")

def display_scouts_roster_with_modal(df: pd.DataFrame):
    """Display Scouts roster with clickable Scout names that open modal dialogs."""
    
    # Initialize session state for selected Scout
    if 'selected_scout' not in st.session_state:
        st.session_state.selected_scout = None
    
    # Check if modal should be displayed
    if st.session_state.selected_scout:
        scout_info = st.session_state.selected_scout
        display_scout_mbc_modal(scout_info['name'], scout_info['id'], scout_info['bsa_number'])
        return
    
    # Display Scout roster table with clickable names
    st.write("**Click on a Scout name to view their MBC assignments and workload**")
    
    # First, we need to get scout IDs from the scouts table since the view might not have them
    conn = get_database_connection()
    if not conn:
        st.error("Database connection error")
        return
    
    try:
        # Get scout IDs by joining with scouts table
        scout_id_query = """
        SELECT s.id, s.first_name, s.last_name, s.bsa_number
        FROM scouts s
        """
        cursor = conn.cursor()
        cursor.execute(scout_id_query)
        scout_ids = {(row[1], row[2], row[3]): row[0] for row in cursor.fetchall()}
        
    except Exception as e:
        st.error(f"Error getting scout IDs: {e}")
        return
    finally:
        conn.close()
    
    # Create a custom display of the dataframe with clickable Scout names
    for index, row in df.iterrows():
        scout_key = (row['first_name'], row['last_name'], row['bsa_number'])
        scout_id = scout_ids.get(scout_key)
        
        if not scout_id:
            continue  # Skip if we can't find the scout ID
            
        with st.container():
            col1, col2, col3, col4, col5, col6 = st.columns([3, 1, 1, 2, 2, 2])
            
            with col1:
                # Make Scout name clickable
                scout_name = f"{row['first_name']} {row['last_name']}"
                if st.button(
                    f"üë§ {scout_name}", 
                    key=f"scout_{scout_id}",
                    help=f"Click to view MBC assignments for {scout_name}"
                ):
                    st.session_state.selected_scout = {
                        'name': scout_name,
                        'id': scout_id,
                        'bsa_number': row['bsa_number']
                    }
                    st.rerun()
                
                st.caption(f"BSA #{row['bsa_number']}")
            
            with col2:
                st.write(f"**{row['rank']}**")
            
            with col3:
                st.write(f"{row['patrol_name'] or 'No Patrol'}")
            
            with col4:
                st.write(f"Unit {row['unit_number']}")
            
            with col5:
                status_color = "üü¢" if row['activity_status'] == 'Active' else "üî¥"
                st.write(f"{status_color} {row['activity_status']}")
            
            with col6:
                position = row['position_title'] or 'No Position'
                st.caption(f"Position: {position}")
        
        st.markdown("---")

# Sidebar navigation
st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Choose a section:",
    ["Database Views", "Manual MBC Matching", "Settings", "CSV Import"],
    index=0
)

# Main content based on selected page
if page == "Settings":
    st.header("‚öôÔ∏è Environment Settings")
    st.markdown("Configure your Merit Badge Manager settings:")
    
    # Load current settings
    env_template = load_env_template()
    current_env = load_env_file()
    
    # Create form for editing settings
    with st.form("env_settings"):
        st.subheader("Configuration")
        
        # Filter out backend server configuration items
        backend_server_configs = {'GITHUB_TOKEN', 'HOST', 'PORT', 'GITHUB_REPO', 'ENVIRONMENT'}
        
        # Merge template with current values
        env_vars = {}
        for key, default_value in env_template.items():
            # Skip backend server configuration items
            if key in backend_server_configs:
                continue
                
            current_value = current_env.get(key, default_value)
            
            if key in ['VALIDATE_BEFORE_IMPORT', 'GENERATE_VALIDATION_REPORTS']:
                # Boolean fields as toggles
                env_vars[key] = 'true' if st.checkbox(
                    f"{key.replace('_', ' ').title()}:",
                    value=current_value.lower() == 'true',
                    help=f"Default: {default_value}"
                ) else 'false'
            else:
                # Regular text fields
                env_vars[key] = st.text_input(
                    f"{key}:", 
                    value=current_value,
                    help=f"Default: {default_value}"
                )
        
        submitted = st.form_submit_button("Save Settings")
        
        if submitted:
            if save_env_file(env_vars):
                st.success("Settings saved successfully!")
                st.balloons()
            else:
                st.error("Failed to save settings.")

elif page == "CSV Import":
    st.header("üìÅ CSV Import & Validation")
    
    # Check if .env file exists
    if not Path(".env").exists():
        st.warning("‚ö†Ô∏è Please configure settings first!")
        st.stop()
    
    # Load environment variables
    current_env = load_env_file()
    roster_file = current_env.get('ROSTER_CSV_FILE', 'roster_report.csv')
    mb_progress_file = current_env.get('MB_PROGRESS_CSV_FILE', 'merit_badge_progress.csv')
    
    st.subheader("üìã Import Status")
    
    # Check if data directory exists
    data_dir = Path("data")
    if not data_dir.exists():
        st.info("Creating data directory...")
        data_dir.mkdir()
    
    # Display expected file locations
    st.write("**Expected file locations:**")
    st.write(f"- Roster CSV: `data/{roster_file}`")
    st.write(f"- Merit Badge Progress CSV: `data/{mb_progress_file}`")
    
    # Check file existence
    roster_path = data_dir / roster_file
    mb_progress_path = data_dir / mb_progress_file
    
    roster_exists = roster_path.exists()
    mb_progress_exists = mb_progress_path.exists()
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**Roster File:**")
        if roster_exists:
            st.success("‚úÖ Found")
        else:
            st.error("‚ùå Not found")
    
    with col2:
        st.write("**Merit Badge Progress File:**")
        if mb_progress_exists:
            st.success("‚úÖ Found")
        else:
            st.warning("‚ö†Ô∏è Not found (optional)")
    
    # Validation results storage in session state
    if 'validation_results' not in st.session_state:
        st.session_state.validation_results = None
    if 'validation_passed' not in st.session_state:
        st.session_state.validation_passed = False
    if 'db_backup_path' not in st.session_state:
        st.session_state.db_backup_path = None
    
    # Import options
    st.subheader("üöÄ Import Actions")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("Validate Only", disabled=not roster_exists):
            with st.spinner("Validating CSV files..."):
                validation_passed, validation_results = run_validation_only(roster_path)
                st.session_state.validation_results = validation_results
                st.session_state.validation_passed = validation_passed
    
    # Display validation results if available
    if st.session_state.validation_results:
        validation_passed = display_validation_results(st.session_state.validation_results)
        st.session_state.validation_passed = validation_passed
        
        # Show import options based on validation results
        if not validation_passed:
            st.subheader("üõ†Ô∏è Import Options")
            st.warning("‚ö†Ô∏è Validation failed. Choose how to proceed:")
            
            col_a, col_b = st.columns(2)
            
            with col_a:
                if st.button("üîß Force Import (Skip Validation)", type="secondary"):
                    with st.spinner("Creating database backup and importing data..."):
                        try:
                            # Create backup before import
                            backup_path = backup_database()
                            if backup_path:
                                st.session_state.db_backup_path = backup_path
                                st.info(f"‚úÖ Database backed up to: {backup_path}")
                            
                            # Create/recreate database
                            st.info("Setting up database...")
                            success = recreate_database_safely("merit_badge_manager.db")
                            if not success:
                                st.error("‚ùå Failed to create database schema!")
                            else:
                                # Import roster data with force flag
                                from import_roster import RosterImporter
                                importer = RosterImporter(ui_mode=True)
                                
                                st.info("Importing roster data (skipping validation)...")
                                success = importer.run_import(force=True)
                                
                                if success:
                                    # Import merit badge progress data if file exists
                                    mb_progress_path = data_dir / mb_progress_file
                                    if mb_progress_path.exists():
                                        st.info("Importing merit badge progress data...")
                                        try:
                                            from import_mb_progress import MeritBadgeProgressImporter
                                            mb_importer = MeritBadgeProgressImporter("merit_badge_manager.db")
                                            mb_success = mb_importer.import_csv(str(mb_progress_path))
                                            
                                            if mb_success:
                                                stats = mb_importer.get_import_summary()
                                                st.info(f"‚úÖ Merit Badge Progress imported: {stats['imported_records']} records")
                                            else:
                                                st.warning("‚ö†Ô∏è Merit Badge Progress import failed, but roster import succeeded")
                                                
                                        except Exception as e:
                                            st.warning(f"‚ö†Ô∏è Merit Badge Progress import error: {e}")
                                    else:
                                        st.info(f"‚ÑπÔ∏è No merit badge progress file found at: data/{mb_progress_file}")
                                    
                                    st.success("‚úÖ Data imported successfully (with validation errors)!")
                                    st.balloons()
                                    # Clear validation results
                                    st.session_state.validation_results = None
                                else:
                                    st.error("‚ùå Import failed!")
                                    # Restore backup if available
                                    if st.session_state.db_backup_path:
                                        if restore_database(st.session_state.db_backup_path):
                                            st.info("üîÑ Database restored from backup")
                                
                        except Exception as e:
                            display_error_with_details("Import error occurred during forced import", e)
                            # Restore backup if available
                            if st.session_state.db_backup_path:
                                if restore_database(st.session_state.db_backup_path):
                                    st.info("üîÑ Database restored from backup")
            
            with col_b:
                if st.button("‚ùå Abort Import", type="secondary"):
                    st.session_state.validation_results = None
                    st.session_state.validation_passed = False
                    st.info("Import aborted. Please fix validation errors and try again.")
                    st.rerun()
    
    with col2:
        # Only enable import if validation passed or no validation has been run
        import_disabled = roster_exists and st.session_state.validation_results is not None and not st.session_state.validation_passed
        
        if st.button("Import Data", disabled=not roster_exists or import_disabled):
            with st.spinner("Validating and importing data..."):
                try:
                    # Run validation first
                    validation_passed, validation_results = run_validation_only(roster_path)
                    
                    if not validation_passed:
                        st.session_state.validation_results = validation_results
                        st.session_state.validation_passed = validation_passed
                        st.error("‚ùå Validation failed! Please review errors above and choose how to proceed.")
                        st.rerun()
                        
                    # Create backup before import
                    backup_path = backup_database()
                    if backup_path:
                        st.session_state.db_backup_path = backup_path
                        st.info(f"‚úÖ Database backed up to: {backup_path}")
                    
                    # Create/recreate database
                    st.info("Setting up database...")
                    success = recreate_database_safely("merit_badge_manager.db")
                    if not success:
                        st.error("‚ùå Failed to create database schema!")
                    else:
                        # Import roster data
                        from import_roster import RosterImporter
                        importer = RosterImporter(ui_mode=True)
                        
                        st.info("Importing roster data...")
                        success = importer.run_import()
                        
                        if success:
                            # Import merit badge progress data if file exists
                            mb_progress_path = data_dir / mb_progress_file
                            if mb_progress_path.exists():
                                st.info("Importing merit badge progress data...")
                                try:
                                    from import_mb_progress import MeritBadgeProgressImporter
                                    mb_importer = MeritBadgeProgressImporter("merit_badge_manager.db")
                                    mb_success = mb_importer.import_csv(str(mb_progress_path))
                                    
                                    if mb_success:
                                        stats = mb_importer.get_import_summary()
                                        st.info(f"‚úÖ Merit Badge Progress imported: {stats['imported_records']} records")
                                    else:
                                        st.warning("‚ö†Ô∏è Merit Badge Progress import failed, but roster import succeeded")
                                        
                                except Exception as e:
                                    st.warning(f"‚ö†Ô∏è Merit Badge Progress import error: {e}")
                            else:
                                st.info(f"‚ÑπÔ∏è No merit badge progress file found at: data/{mb_progress_file}")
                            
                            st.success("‚úÖ Data imported successfully!")
                            st.balloons()
                            # Clear validation results
                            st.session_state.validation_results = None
                        else:
                            st.error("‚ùå Import failed!")
                            # Restore backup if available
                            if st.session_state.db_backup_path:
                                if restore_database(st.session_state.db_backup_path):
                                    st.info("üîÑ Database restored from backup")
                        
                except Exception as e:
                    display_error_with_details("Import error occurred during normal import", e)
                    # Restore backup if available
                    if st.session_state.db_backup_path:
                        if restore_database(st.session_state.db_backup_path):
                            st.info("üîÑ Database restored from backup")
    
    with col3:
        if st.button("Reset Database"):
            with st.spinner("Resetting database..."):
                try:
                    # Create backup before reset
                    backup_path = backup_database()
                    if backup_path:
                        st.info(f"‚úÖ Database backed up to: {backup_path}")
                    
                    # Remove existing database
                    db_path = Path("merit_badge_manager.db")
                    if db_path.exists():
                        db_path.unlink()
                    
                    # Recreate schema
                    create_database_schema("merit_badge_manager.db", include_youth=True)
                    st.success("‚úÖ Database reset successfully!")
                    
                    # Clear session state
                    st.session_state.validation_results = None
                    st.session_state.validation_passed = False
                    
                except Exception as e:
                    display_error_with_details("Database reset error occurred", e)
    
    # Show backup information if available
    if st.session_state.db_backup_path:
        st.info(f"üíæ **Current backup:** `{st.session_state.db_backup_path}`")
        
        col_restore, col_cleanup = st.columns(2)
        with col_restore:
            if st.button("üîÑ Restore from Backup"):
                if restore_database(st.session_state.db_backup_path):
                    st.success("‚úÖ Database restored from backup!")
                    st.session_state.validation_results = None
                    st.session_state.validation_passed = False
                    st.rerun()
                else:
                    st.error("‚ùå Failed to restore from backup")
        
        with col_cleanup:
            if st.button("üóëÔ∏è Remove Backup"):
                try:
                    Path(st.session_state.db_backup_path).unlink()
                    st.session_state.db_backup_path = None
                    st.success("‚úÖ Backup file removed")
                    st.rerun()
                except Exception as e:
                    st.error(f"Error removing backup: {e}")

elif page == "Database Views":
    st.header("üìä Database Views")
    
    # Check if database exists
    if not Path("merit_badge_manager.db").exists():
        st.warning("‚ö†Ô∏è Database not found. Please import data first!")
        st.stop()
    
    # Get available views
    views = get_available_views()
    
    if not views:
        st.warning("No database views found.")
        st.stop()
    
    # Group views by type
    adult_views = [v for v in views if 'adult' in v or v in ['training_expiration_summary', 'merit_badge_counselors', 'current_positions', 'registered_volunteers', 'mbc_workload_summary']]
    youth_views = [v for v in views if 'scout' in v or v in ['advancement_progress_by_rank', 'primary_parent_contacts', 'patrol_assignments']]
    other_views = [v for v in views if v not in adult_views and v not in youth_views]
    
    # Sidebar for view selection
    st.sidebar.subheader("Select a View")
    
    view_type = st.sidebar.radio("View Category:", ["Adult Views", "Youth Views", "Other Views"] if other_views else ["Adult Views", "Youth Views"])
    
    if view_type == "Adult Views" and adult_views:
        selected_view = st.sidebar.selectbox("Adult Views:", adult_views)
    elif view_type == "Youth Views" and youth_views:
        selected_view = st.sidebar.selectbox("Youth Views:", youth_views)
    elif view_type == "Other Views" and other_views:
        selected_view = st.sidebar.selectbox("Other Views:", other_views)
    else:
        selected_view = None
    
    # Display selected view
    if selected_view:
        st.subheader(f"üìã {selected_view.replace('_', ' ').title()}")
        
        # Add view description
        view_descriptions = {
            'adults_missing_data': 'Adults with missing required information',
            'training_expiration_summary': 'Training status and expiration dates',
            'merit_badge_counselors': 'Merit badge counselor assignments',
            'current_positions': 'Current adult positions',
            'registered_volunteers': 'All adults with BSA numbers (registered volunteers) and their active roles',
            'scouts_missing_data': 'Scouts with missing required information',
            'active_scouts_with_positions': 'Scout roster with ranks and positions',
            'merit_badge_progress_summary': 'Merit badge progress overview',
            'scouts_needing_counselors': 'Scouts who need counselor assignments',
            'advancement_progress_by_rank': 'Advancement statistics by rank',
            'primary_parent_contacts': 'Primary parent/guardian contacts',
            'scout_training_expiration_summary': 'Scout training status',
            'patrol_assignments': 'Patrol membership',
            'scout_mbc_assignments': 'Scout-to-MBC assignment tracking with status details',
            'mbc_workload_summary': 'MBC workload statistics and assignment counts'
        }
        
        if selected_view in view_descriptions:
            st.info(view_descriptions[selected_view])
        
        # Display the view data
        display_view_data(selected_view)
    else:
        st.info("Select a view from the sidebar to display data.")

elif page == "Manual MBC Matching":
    st.header("üéØ Manual MBC Matching")
    st.markdown("Manually resolve unmatched Merit Badge Counselor names from imported data.")
    
    # Check if database exists
    if not Path("merit_badge_manager.db").exists():
        st.warning("‚ö†Ô∏è Database not found. Please import data first!")
        st.stop()
    
    # Import the manual matcher
    try:
        from manual_mbc_matcher import ManualMBCMatcher
        matcher = ManualMBCMatcher("merit_badge_manager.db")
    except ImportError as e:
        st.error(f"Error importing manual matcher: {e}")
        st.stop()
    
    # Get statistics
    with st.spinner("Loading matching statistics..."):
        stats = matcher.get_matching_statistics()
    
    if not stats:
        st.error("Error loading matching statistics.")
        st.stop()
    
    # Display statistics dashboard
    st.subheader("üìä Matching Progress")
    
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Total Unmatched", stats.get('total_unmatched', 0))
    with col2:
        st.metric("Manually Matched", stats.get('manually_matched', 0))
    with col3:
        st.metric("Unresolved", stats.get('unresolved', 0))
    with col4:
        st.metric("Total Assignments", stats.get('total_assignments', 0))
    
    col5, col6, col7, col8 = st.columns(4)
    with col5:
        st.metric("Skipped", stats.get('skipped', 0))
    with col6:
        st.metric("Marked Invalid", stats.get('marked_invalid', 0))
    with col7:
        st.metric("New Adult Needed", stats.get('create_new', 0))
    with col8:
        progress = 0
        if stats.get('total_unmatched', 0) > 0:
            resolved_count = stats.get('total_unmatched', 0) - stats.get('unresolved', 0)
            progress = (resolved_count / stats.get('total_unmatched', 0)) * 100
        st.metric("Progress", f"{progress:.1f}%")
    
    # Get unmatched names
    unmatched_names = matcher.get_unmatched_mbc_names()
    
    if not unmatched_names:
        st.success("üéâ All MBC names have been resolved!")
        st.balloons()
        st.stop()
    
    st.markdown("---")
    
    # Manual matching interface
    st.subheader("üîç Manual Matching Interface")
    
    # User identification
    col_user, col_filter = st.columns([1, 2])
    with col_user:
        user_name = st.text_input("Your Name", value="Anonymous", help="Used for audit trail")
    with col_filter:
        # Filter options
        filter_option = st.selectbox(
            "Filter by:",
            ["All Unmatched", "High Assignment Count", "Recently Added"],
            help="Filter unmatched names to focus on specific criteria"
        )
    
    # Apply filter
    if filter_option == "High Assignment Count":
        unmatched_names = [name for name in unmatched_names if name['assignment_count'] >= 3]
    elif filter_option == "Recently Added":
        # For this demo, we'll show all since we don't have dates
        pass
    
    # Pagination
    items_per_page = 5
    total_items = len(unmatched_names)
    total_pages = (total_items + items_per_page - 1) // items_per_page
    
    if total_pages > 1:
        col_prev, col_page, col_next = st.columns([1, 2, 1])
        with col_page:
            current_page = st.selectbox("Page", range(1, total_pages + 1), key="page_selector")
        
        start_idx = (current_page - 1) * items_per_page
        end_idx = min(start_idx + items_per_page, total_items)
        page_items = unmatched_names[start_idx:end_idx]
    else:
        page_items = unmatched_names
        current_page = 1
    
    # Process each unmatched name
    for idx, unmatched_item in enumerate(page_items):
        mbc_name_raw = unmatched_item['mbc_name_raw']
        assignment_count = unmatched_item['assignment_count']
        
        st.markdown(f"### {idx + 1}. `{mbc_name_raw}`")
        
        col_info, col_matches = st.columns([1, 2])
        
        with col_info:
            st.markdown("**Unmatched Name Details:**")
            st.write(f"**Name:** {mbc_name_raw}")
            st.write(f"**Assignment Count:** {assignment_count}")
            st.write(f"**Merit Badges:** {unmatched_item.get('merit_badges', 'N/A')}")
            
            # Show affected scouts (truncated)
            scouts = unmatched_item.get('scouts', '')
            if scouts and len(scouts) > 100:
                scouts = scouts[:100] + "..."
            st.write(f"**Affected Scouts:** {scouts}")
        
        with col_matches:
            st.markdown("**Potential Adult Matches:**")
            
            with st.spinner(f"Finding matches for '{mbc_name_raw}'..."):
                potential_matches = matcher.get_potential_adult_matches(mbc_name_raw, limit=8)
            
            if potential_matches:
                # Display potential matches with confidence indicators
                for match_idx, match in enumerate(potential_matches):
                    confidence = match['confidence_score']
                    emoji = matcher.get_confidence_emoji(confidence)
                    
                    # Create a container for each match
                    match_container = st.container()
                    with match_container:
                        match_col1, match_col2, match_col3 = st.columns([3, 1, 1])
                        
                        with match_col1:
                            st.write(f"{emoji} **{match['full_name']}**")
                            st.write(f"BSA #: {match.get('bsa_number', 'N/A')} | Email: {match.get('email', 'N/A')}")
                            if match.get('merit_badges'):
                                mb_badges = match['merit_badges']
                                if len(mb_badges) > 80:
                                    mb_badges = mb_badges[:80] + "..."
                                st.write(f"Merit Badges: {mb_badges}")
                        
                        with match_col2:
                            st.write(f"**{confidence:.1%}**")
                            st.caption("Confidence")
                        
                        with match_col3:
                            if st.button(f"Match", key=f"match_{mbc_name_raw}_{match['id']}"):
                                # Record the match
                                success = matcher.record_manual_match(
                                    unmatched_mbc_name=mbc_name_raw,
                                    match_action='matched',
                                    matched_adult_id=match['id'],
                                    confidence_score=confidence,
                                    user_name=user_name,
                                    notes=f"Manually matched to {match['full_name']} with {confidence:.1%} confidence"
                                )
                                
                                if success:
                                    st.success(f"‚úÖ Matched '{mbc_name_raw}' to {match['full_name']}")
                                    st.rerun()
                                else:
                                    st.error("‚ùå Error recording match")
                        
                        st.markdown("---")
                
            else:
                st.warning("No potential matches found with sufficient confidence.")
        
        # Action buttons for each unmatched name
        st.markdown("**Actions:**")
        action_col1, action_col2, action_col3, action_col4 = st.columns(4)
        
        with action_col1:
            if st.button(f"Skip", key=f"skip_{mbc_name_raw}"):
                success = matcher.record_manual_match(
                    unmatched_mbc_name=mbc_name_raw,
                    match_action='skipped',
                    user_name=user_name,
                    notes="Skipped for now"
                )
                if success:
                    st.info(f"‚è≠Ô∏è Skipped '{mbc_name_raw}'")
                    st.rerun()
        
        with action_col2:
            if st.button(f"Mark Invalid", key=f"invalid_{mbc_name_raw}"):
                success = matcher.record_manual_match(
                    unmatched_mbc_name=mbc_name_raw,
                    match_action='marked_invalid',
                    user_name=user_name,
                    notes="Marked as invalid MBC name"
                )
                if success:
                    st.warning(f"‚ùå Marked '{mbc_name_raw}' as invalid")
                    st.rerun()
        
        with action_col3:
            if st.button(f"Create New", key=f"create_{mbc_name_raw}"):
                success = matcher.record_manual_match(
                    unmatched_mbc_name=mbc_name_raw,
                    match_action='create_new',
                    user_name=user_name,
                    notes="New adult record needed"
                )
                if success:
                    st.info(f"‚ûï Marked '{mbc_name_raw}' for new adult creation")
                    st.rerun()
        
        with action_col4:
            if st.button(f"Undo", key=f"undo_{mbc_name_raw}"):
                success = matcher.undo_manual_match(mbc_name_raw, user_name)
                if success:
                    st.info(f"‚Ü©Ô∏è Undid previous decision for '{mbc_name_raw}'")
                    st.rerun()
        
        st.markdown("---")
    
    # Pagination info
    if total_pages > 1:
        st.info(f"Showing {len(page_items)} of {total_items} unmatched names (Page {current_page} of {total_pages})")
    
    # User activity summary
    if stats.get('user_activity'):
        st.subheader("üë• User Activity Summary")
        user_activity_df = pd.DataFrame(stats['user_activity'])
        st.dataframe(user_activity_df, use_container_width=True)

# Footer
st.markdown("---")
st.markdown("*Merit Badge Manager - Streamlit Web UI*")