#!/usr/bin/env python3
"""
Merit Badge Manager - Streamlit Web UI

A basic web interface for:
- Managing .env configuration settings
- Triggering CSV import and validation
- Displaying database views

Author: GitHub Copilot
Issue: #16
"""

import streamlit as st
import os
import sys
import sqlite3
import pandas as pd
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import logging
import shutil
from datetime import datetime

# Add the src and scripts directories to the Python path
sys.path.insert(0, str(Path(__file__).parent / "src"))
sys.path.insert(0, str(Path(__file__).parent / "scripts"))
sys.path.insert(0, str(Path(__file__).parent / "db-scripts"))

from csv_validator import CSVValidator, ValidationResult, print_validation_summary
from roster_parser import RosterParser
from setup_database import create_database_schema

# Configure page
st.set_page_config(
    page_title="Merit Badge Manager",
    page_icon="üèïÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Application title
st.title("üèïÔ∏è Merit Badge Manager")
st.markdown("---")

def load_env_template() -> Dict[str, str]:
    """Load the .env.template file to get default values and structure."""
    env_template = {}
    template_path = Path(".env.template")
    
    if template_path.exists():
        with open(template_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_template[key] = value
    
    return env_template

def load_env_file() -> Dict[str, str]:
    """Load existing .env file if it exists."""
    env_vars = {}
    env_path = Path(".env")
    
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key] = value
    
    return env_vars

def save_env_file(env_vars: Dict[str, str]) -> bool:
    """Save environment variables to .env file."""
    try:
        with open(".env", 'w') as f:
            f.write("# Environment variables for Merit Badge Manager\n")
            f.write("# Generated by Streamlit UI\n\n")
            
            for key, value in env_vars.items():
                f.write(f"{key}={value}\n")
        
        return True
    except Exception as e:
        st.error(f"Error saving .env file: {e}")
        return False

def backup_database(db_path: str = "merit_badge_manager.db") -> Optional[str]:
    """
    Create a backup of the current database.
    
    Returns:
        Path to backup file if successful, None otherwise
    """
    if not Path(db_path).exists():
        return None
    
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{db_path}.backup_{timestamp}"
        shutil.copy2(db_path, backup_path)
        return backup_path
    except Exception as e:
        st.error(f"Error creating database backup: {e}")
        return None

def restore_database(backup_path: str, db_path: str = "merit_badge_manager.db") -> bool:
    """
    Restore database from backup.
    
    Returns:
        True if successful, False otherwise
    """
    try:
        if Path(backup_path).exists():
            shutil.copy2(backup_path, db_path)
            return True
        return False
    except Exception as e:
        st.error(f"Error restoring database: {e}")
        return False

def recreate_database_safely(db_path: str = "merit_badge_manager.db") -> bool:
    """
    Safely recreate the database by handling file locks and ensuring clean deletion.
    
    Returns:
        True if successful, False otherwise
    """
    try:
        import time
        import sqlite3
        
        # First, try to close any existing connections by attempting a dummy connection
        # This helps ensure no lingering connections are holding locks
        if Path(db_path).exists():
            try:
                # Try to connect and immediately close to flush any pending operations
                conn = sqlite3.connect(db_path, timeout=1.0)
                conn.close()
                time.sleep(0.1)  # Brief pause to allow cleanup
            except:
                pass  # Ignore connection errors, we're just trying to clean up
            
            # Remove the existing database file
            try:
                Path(db_path).unlink()
                time.sleep(0.1)  # Brief pause after deletion
            except FileNotFoundError:
                pass  # File already gone, that's fine
            except PermissionError as e:
                st.error(f"‚ùå Cannot delete database file (file may be in use): {e}")
                return False
            except Exception as e:
                st.error(f"‚ùå Error deleting database file: {e}")
                return False
        
        # Create the new database schema
        success = create_database_schema(db_path, include_youth=True)
        if not success:
            st.error("‚ùå Database schema creation failed")
            return False
        
        return True
        
    except Exception as e:
        st.error(f"‚ùå Unexpected error during database recreation: {e}")
        return False

def display_validation_results(results: Dict[str, ValidationResult]) -> bool:
    """
    Display validation results in Streamlit format.
    
    Returns:
        True if all validations passed, False otherwise
    """
    overall_valid = True
    total_errors = 0
    total_warnings = 0
    
    st.subheader("üìã Validation Results")
    
    for file_type, result in results.items():
        # Create expandable section for each file type
        with st.expander(f"{'‚úÖ' if result.is_valid else '‚ùå'} {file_type} - {'PASS' if result.is_valid else 'FAIL'}", expanded=not result.is_valid):
            col1, col2, col3, col4, col5 = st.columns(5)
            
            with col1:
                st.metric("Rows Processed", result.row_count)
            with col2:
                st.metric("Valid Rows", result.valid_rows)
            with col3:
                st.metric("Skipped Rows", len(result.skipped_records), delta=None if len(result.skipped_records) == 0 else f"-{len(result.skipped_records)}")
            with col4:
                st.metric("Errors", len(result.errors), delta=None if len(result.errors) == 0 else f"-{len(result.errors)}")
            with col5:
                st.metric("Warnings", len(result.warnings), delta=None if len(result.warnings) == 0 else f"-{len(result.warnings)}")
            
            # Show skipped records
            if result.skipped_records:
                st.info("**Records skipped (duplicates):**")
                for skipped in result.skipped_records:
                    st.info(f"‚Ä¢ {skipped}")
            
            # Show errors
            if result.errors:
                st.error("**Errors found:**")
                for error in result.errors:
                    st.error(f"‚Ä¢ {error}")
            
            # Show warnings
            if result.warnings:
                st.warning("**Warnings found:**")
                for warning in result.warnings:
                    st.warning(f"‚Ä¢ {warning}")
        
        if not result.is_valid:
            overall_valid = False
        
        total_errors += len(result.errors)
        total_warnings += len(result.warnings)
    
    # Overall summary
    if overall_valid:
        st.success(f"üéâ **All validations passed!** Total warnings: {total_warnings}")
    else:
        st.error(f"‚ùå **Validation failed!** Total errors: {total_errors}, Total warnings: {total_warnings}")
        st.error("üö® Cannot proceed with import - Please fix validation errors first!")
    
    return overall_valid

def run_validation_only(roster_file_path: Path) -> Tuple[bool, Dict[str, ValidationResult]]:
    """
    Run validation on roster files and return results.
    
    Returns:
        Tuple of (overall_valid, results_dict)
    """
    try:
        # Parse the roster file to get adult and youth sections
        parser = RosterParser(str(roster_file_path), "output")
        adult_file, youth_file = parser.parse_roster()
        
        # Validate the parsed output files
        validator = CSVValidator()
        results = {}
        
        if os.path.exists(adult_file):
            results["Adult Roster"] = validator.validate_adult_roster(adult_file)
        
        if os.path.exists(youth_file):
            results["Youth Roster"] = validator.validate_youth_roster(youth_file)
        
        # Calculate overall validity
        overall_valid = all(result.is_valid for result in results.values())
        
        return overall_valid, results
        
    except Exception as e:
        st.error(f"Validation error: {e}")
        return False, {}

def get_database_connection():
    """Get SQLite database connection."""
    db_path = "merit_badge_manager.db"
    if not Path(db_path).exists():
        return None
    
    try:
        conn = sqlite3.connect(db_path)
        return conn
    except Exception as e:
        st.error(f"Database connection error: {e}")
        return None

def get_available_views() -> List[str]:
    """Get list of available database views."""
    conn = get_database_connection()
    if not conn:
        return []
    
    try:
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='view' ORDER BY name;")
        views = [row[0] for row in cursor.fetchall()]
        conn.close()
        return views
    except Exception as e:
        st.error(f"Error fetching views: {e}")
        if conn:
            conn.close()
        return []

def display_view_data(view_name: str):
    """Display data from a database view."""
    conn = get_database_connection()
    if not conn:
        st.warning("Database not found. Please import data first.")
        return
    
    try:
        df = pd.read_sql_query(f"SELECT * FROM {view_name}", conn)
        st.dataframe(df, use_container_width=True)
        
        # Display record count
        st.info(f"Total records: {len(df)}")
        
    except Exception as e:
        st.error(f"Error loading view {view_name}: {e}")
    finally:
        conn.close()

# Sidebar navigation
st.sidebar.title("Navigation")
page = st.sidebar.selectbox(
    "Choose a section:",
    ["Settings", "CSV Import", "Database Views"]
)

# Main content based on selected page
if page == "Settings":
    st.header("‚öôÔ∏è Environment Settings")
    st.markdown("Configure your Merit Badge Manager settings:")
    
    # Load current settings
    env_template = load_env_template()
    current_env = load_env_file()
    
    # Create form for editing settings
    with st.form("env_settings"):
        st.subheader("Configuration")
        
        # Filter out backend server configuration items
        backend_server_configs = {'GITHUB_TOKEN', 'HOST', 'PORT', 'GITHUB_REPO', 'ENVIRONMENT'}
        
        # Merge template with current values
        env_vars = {}
        for key, default_value in env_template.items():
            # Skip backend server configuration items
            if key in backend_server_configs:
                continue
                
            current_value = current_env.get(key, default_value)
            
            if key in ['VALIDATE_BEFORE_IMPORT', 'GENERATE_VALIDATION_REPORTS']:
                # Boolean fields as toggles
                env_vars[key] = 'true' if st.checkbox(
                    f"{key.replace('_', ' ').title()}:",
                    value=current_value.lower() == 'true',
                    help=f"Default: {default_value}"
                ) else 'false'
            else:
                # Regular text fields
                env_vars[key] = st.text_input(
                    f"{key}:", 
                    value=current_value,
                    help=f"Default: {default_value}"
                )
        
        submitted = st.form_submit_button("Save Settings")
        
        if submitted:
            if save_env_file(env_vars):
                st.success("Settings saved successfully!")
                st.balloons()
            else:
                st.error("Failed to save settings.")

elif page == "CSV Import":
    st.header("üìÅ CSV Import & Validation")
    
    # Check if .env file exists
    if not Path(".env").exists():
        st.warning("‚ö†Ô∏è Please configure settings first!")
        st.stop()
    
    # Load environment variables
    current_env = load_env_file()
    roster_file = current_env.get('ROSTER_CSV_FILE', 'roster_report.csv')
    mb_progress_file = current_env.get('MB_PROGRESS_CSV_FILE', 'merit_badge_progress.csv')
    
    st.subheader("üìã Import Status")
    
    # Check if data directory exists
    data_dir = Path("data")
    if not data_dir.exists():
        st.info("Creating data directory...")
        data_dir.mkdir()
    
    # Display expected file locations
    st.write("**Expected file locations:**")
    st.write(f"- Roster CSV: `data/{roster_file}`")
    st.write(f"- Merit Badge Progress CSV: `data/{mb_progress_file}`")
    
    # Check file existence
    roster_path = data_dir / roster_file
    mb_progress_path = data_dir / mb_progress_file
    
    roster_exists = roster_path.exists()
    mb_progress_exists = mb_progress_path.exists()
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.write("**Roster File:**")
        if roster_exists:
            st.success("‚úÖ Found")
        else:
            st.error("‚ùå Not found")
    
    with col2:
        st.write("**Merit Badge Progress File:**")
        if mb_progress_exists:
            st.success("‚úÖ Found")
        else:
            st.warning("‚ö†Ô∏è Not found (optional)")
    
    # Validation results storage in session state
    if 'validation_results' not in st.session_state:
        st.session_state.validation_results = None
    if 'validation_passed' not in st.session_state:
        st.session_state.validation_passed = False
    if 'db_backup_path' not in st.session_state:
        st.session_state.db_backup_path = None
    
    # Import options
    st.subheader("üöÄ Import Actions")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("Validate Only", disabled=not roster_exists):
            with st.spinner("Validating CSV files..."):
                validation_passed, validation_results = run_validation_only(roster_path)
                st.session_state.validation_results = validation_results
                st.session_state.validation_passed = validation_passed
    
    # Display validation results if available
    if st.session_state.validation_results:
        validation_passed = display_validation_results(st.session_state.validation_results)
        st.session_state.validation_passed = validation_passed
        
        # Show import options based on validation results
        if not validation_passed:
            st.subheader("üõ†Ô∏è Import Options")
            st.warning("‚ö†Ô∏è Validation failed. Choose how to proceed:")
            
            col_a, col_b = st.columns(2)
            
            with col_a:
                if st.button("üîß Force Import (Skip Validation)", type="secondary"):
                    with st.spinner("Creating database backup and importing data..."):
                        try:
                            # Create backup before import
                            backup_path = backup_database()
                            if backup_path:
                                st.session_state.db_backup_path = backup_path
                                st.info(f"‚úÖ Database backed up to: {backup_path}")
                            
                            # Create/recreate database
                            st.info("Setting up database...")
                            success = recreate_database_safely("merit_badge_manager.db")
                            if not success:
                                st.error("‚ùå Failed to create database schema!")
                            else:
                                # Import roster data with force flag
                                from import_roster import RosterImporter
                                importer = RosterImporter(ui_mode=True)
                                
                                st.info("Importing roster data (skipping validation)...")
                                success = importer.run_import(force=True)
                                
                                if success:
                                    st.success("‚úÖ Data imported successfully (with validation errors)!")
                                    st.balloons()
                                    # Clear validation results
                                    st.session_state.validation_results = None
                                else:
                                    st.error("‚ùå Import failed!")
                                    # Restore backup if available
                                    if st.session_state.db_backup_path:
                                        if restore_database(st.session_state.db_backup_path):
                                            st.info("üîÑ Database restored from backup")
                                
                        except Exception as e:
                            st.error(f"Import error: {e}")
                            # Restore backup if available
                            if st.session_state.db_backup_path:
                                if restore_database(st.session_state.db_backup_path):
                                    st.info("üîÑ Database restored from backup")
            
            with col_b:
                if st.button("‚ùå Abort Import", type="secondary"):
                    st.session_state.validation_results = None
                    st.session_state.validation_passed = False
                    st.info("Import aborted. Please fix validation errors and try again.")
                    st.rerun()
    
    with col2:
        # Only enable import if validation passed or no validation has been run
        import_disabled = roster_exists and st.session_state.validation_results is not None and not st.session_state.validation_passed
        
        if st.button("Import Data", disabled=not roster_exists or import_disabled):
            with st.spinner("Validating and importing data..."):
                try:
                    # Run validation first
                    validation_passed, validation_results = run_validation_only(roster_path)
                    
                    if not validation_passed:
                        st.session_state.validation_results = validation_results
                        st.session_state.validation_passed = validation_passed
                        st.error("‚ùå Validation failed! Please review errors above and choose how to proceed.")
                        st.rerun()
                        
                    # Create backup before import
                    backup_path = backup_database()
                    if backup_path:
                        st.session_state.db_backup_path = backup_path
                        st.info(f"‚úÖ Database backed up to: {backup_path}")
                    
                    # Create/recreate database
                    st.info("Setting up database...")
                    success = recreate_database_safely("merit_badge_manager.db")
                    if not success:
                        st.error("‚ùå Failed to create database schema!")
                    else:
                        # Import roster data
                        from import_roster import RosterImporter
                        importer = RosterImporter(ui_mode=True)
                        
                        st.info("Importing roster data...")
                        success = importer.run_import()
                        
                        if success:
                            st.success("‚úÖ Data imported successfully!")
                            st.balloons()
                            # Clear validation results
                            st.session_state.validation_results = None
                        else:
                            st.error("‚ùå Import failed!")
                            # Restore backup if available
                            if st.session_state.db_backup_path:
                                if restore_database(st.session_state.db_backup_path):
                                    st.info("üîÑ Database restored from backup")
                        
                except Exception as e:
                    st.error(f"Import error: {e}")
                    # Restore backup if available
                    if st.session_state.db_backup_path:
                        if restore_database(st.session_state.db_backup_path):
                            st.info("üîÑ Database restored from backup")
    
    with col3:
        if st.button("Reset Database"):
            with st.spinner("Resetting database..."):
                try:
                    # Create backup before reset
                    backup_path = backup_database()
                    if backup_path:
                        st.info(f"‚úÖ Database backed up to: {backup_path}")
                    
                    # Remove existing database
                    db_path = Path("merit_badge_manager.db")
                    if db_path.exists():
                        db_path.unlink()
                    
                    # Recreate schema
                    create_database_schema("merit_badge_manager.db", include_youth=True)
                    st.success("‚úÖ Database reset successfully!")
                    
                    # Clear session state
                    st.session_state.validation_results = None
                    st.session_state.validation_passed = False
                    
                except Exception as e:
                    st.error(f"Reset error: {e}")
    
    # Show backup information if available
    if st.session_state.db_backup_path:
        st.info(f"üíæ **Current backup:** `{st.session_state.db_backup_path}`")
        
        col_restore, col_cleanup = st.columns(2)
        with col_restore:
            if st.button("üîÑ Restore from Backup"):
                if restore_database(st.session_state.db_backup_path):
                    st.success("‚úÖ Database restored from backup!")
                    st.session_state.validation_results = None
                    st.session_state.validation_passed = False
                    st.rerun()
                else:
                    st.error("‚ùå Failed to restore from backup")
        
        with col_cleanup:
            if st.button("üóëÔ∏è Remove Backup"):
                try:
                    Path(st.session_state.db_backup_path).unlink()
                    st.session_state.db_backup_path = None
                    st.success("‚úÖ Backup file removed")
                    st.rerun()
                except Exception as e:
                    st.error(f"Error removing backup: {e}")

elif page == "Database Views":
    st.header("üìä Database Views")
    
    # Check if database exists
    if not Path("merit_badge_manager.db").exists():
        st.warning("‚ö†Ô∏è Database not found. Please import data first!")
        st.stop()
    
    # Get available views
    views = get_available_views()
    
    if not views:
        st.warning("No database views found.")
        st.stop()
    
    # Group views by type
    adult_views = [v for v in views if 'adult' in v or v in ['training_expiration_summary', 'merit_badge_counselors', 'current_positions']]
    youth_views = [v for v in views if 'scout' in v or v in ['advancement_progress_by_rank', 'primary_parent_contacts', 'patrol_assignments']]
    other_views = [v for v in views if v not in adult_views and v not in youth_views]
    
    # Sidebar for view selection
    st.sidebar.subheader("Select a View")
    
    view_type = st.sidebar.radio("View Category:", ["Adult Views", "Youth Views", "Other Views"] if other_views else ["Adult Views", "Youth Views"])
    
    if view_type == "Adult Views" and adult_views:
        selected_view = st.sidebar.selectbox("Adult Views:", adult_views)
    elif view_type == "Youth Views" and youth_views:
        selected_view = st.sidebar.selectbox("Youth Views:", youth_views)
    elif view_type == "Other Views" and other_views:
        selected_view = st.sidebar.selectbox("Other Views:", other_views)
    else:
        selected_view = None
    
    # Display selected view
    if selected_view:
        st.subheader(f"üìã {selected_view.replace('_', ' ').title()}")
        
        # Add view description
        view_descriptions = {
            'adults_missing_data': 'Adults with missing required information',
            'training_expiration_summary': 'Training status and expiration dates',
            'merit_badge_counselors': 'Merit badge counselor assignments',
            'current_positions': 'Current adult positions',
            'scouts_missing_data': 'Scouts with missing required information',
            'active_scouts_with_positions': 'Active scouts and their positions',
            'merit_badge_progress_summary': 'Merit badge progress overview',
            'scouts_needing_counselors': 'Scouts who need counselor assignments',
            'advancement_progress_by_rank': 'Advancement statistics by rank',
            'primary_parent_contacts': 'Primary parent/guardian contacts',
            'scout_training_expiration_summary': 'Scout training status',
            'patrol_assignments': 'Patrol membership'
        }
        
        if selected_view in view_descriptions:
            st.info(view_descriptions[selected_view])
        
        # Display the view data
        display_view_data(selected_view)
    else:
        st.info("Select a view from the sidebar to display data.")

# Footer
st.markdown("---")
st.markdown("*Merit Badge Manager - Streamlit Web UI*")